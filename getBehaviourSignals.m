function [a_bodyParts, refStruct] = getBehaviourSignals(dlcTable)
%GETBEHAVIOURSIGNALS reads the CSV file generated by DeepLabCuts and
%extracts the angle for whisker-related bodyparts (from names containing a
%'w' in their names) and the nose (which is called 'nose') taking as
%reference a line from the headplate to the nose.
%   [a_bodyParts] = getBehaviourSignals(dlcTable)
% INPUTS
%       dlcTable - obtained from function readDLCData.
% OUTPUTS
%       a_bodyParts - table containing the
%Emilio Isaias-Camacho @GrohLab 2022

fnOpts = {'UniformOutput', false};
% Mean pixel position of the headplate and the nose to draw the middle
% reference line.
hnCoords = reshape( mean( dlcTable{:,{'headplate', 'nose'}}(:,[1,2,4,5]) ),...
    2, [] );
% Choosing the point with furthest distance from the origin. Should be the
% nose.
[~, noseSel] = max(vecnorm(hnCoords, 2, 2));
% Taking 1/5 from the nose or 4/5 from the headplate as a reference middle
% point.
midlPt = hnCoords(:, noseSel) - diff(hnCoords, 1, 2)/5;
% Getting the line that divides the mouse in half sagittally
mdl = fit_poly(hnCoords(1,:), hnCoords(2,:), 1);
refStruct = struct('MiddleLine', mdl, 'MiddlePoint', midlPt);
% [n, d] = getHesseLineForm(mdl);
% Getting the name of the variables to search for 'w' - whisker names, and
% nose.
avFlags = contains(string(dlcTable.Properties.VariableNames), ["w";"nose"]);
avNames = dlcTable.Properties.VariableNames(avFlags);
% Computing the slope for all whisker body parts and nose with respect to
% the middle point and then the angle m = (y_2 - y_1) / (x_2 - x_1)
m_bodyParts = (midlPt(2) - dlcTable{:, avNames}(:,2:3:end))./...
    (midlPt(1) - dlcTable{:, avNames}(:,1:3:end));
% Computing the angle between the bodypart and the reference line.
a_bodyParts = angleBetweenLines(mdl(1), m_bodyParts, 'deg');
% Unwrapping jumps from Â±90 degrees using a variation from MATLAB unwrap
% function.
a_bodyParts = arrayfun(@(x) unwrapDLC(a_bodyParts(:,x), 90), 1:sum(avFlags),...
    fnOpts{:} );
% Wrapping up the results in a table.
a_bodyParts = table( a_bodyParts{:}, 'VariableNames', avNames );
end
% Local function taken from the MATLAB implementation of the unwrap
% function LocalUnwrap.
function p = unwrapDLC(p, cutoff)
%LocalUnwrap   Unwraps column vector of phase values.
m = length(p);

% Unwrap phase angles.  Algorithm minimizes the incremental phase variation
% by constraining it to the range [-pi,pi]
dp = diff(p,1,1);                % Incremental phase variations

% Compute an integer describing how many times 2*pi we are off:
% dp in [-pi, pi]: dp_corr = 0,
% elseif dp in [-3*pi, 3*pi]: dp_corr = 1,
% else if dp in [-5*pi, 5*pi]: dp_corr = 2, ...
dp_corr = dp./(2*pi);

% We want to do round(dp_corr), except that we want the tie-break at n+0.5
% to round towards zero instead of away from zero (that is, (2n+1)*pi will
% be shifted by 2n*pi, not by (2n+2)*pi):
roundDown = abs(rem(dp_corr, 1)) <= 0.5;
dp_corr(roundDown) = fix(dp_corr(roundDown));

dp_corr = round(dp_corr);

% Stop the jump from happening if dp < cutoff (no effect if cutoff <= pi)
dp_corr(abs(dp) < cutoff) = 0;

% Integrate corrections and add to P to produce smoothed phase values
% taking the full range into consideration
p(2:m,:) = p(2:m,:) - (2*cutoff)*cumsum(sign(dp_corr),1);
end
