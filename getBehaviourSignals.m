function [a_bodyParts, refStruct] = getBehaviourSignals(dlcTable)
%GETBEHAVIOURSIGNALS reads the CSV file generated by DeepLabCuts and
%extracts the angle for whisker-related bodyparts (from names containing a
%'w' in their names) and the nose (which is called 'nose') taking as
%reference a line from the headplate to the nose.
%   [a_bodyParts] = getBehaviourSignals(dlcTable)
% INPUTS
%       dlcTable - obtained from function readDLCData.
% OUTPUTS
%       a_bodyParts - table containing the
%Emilio Isaias-Camacho @GrohLab 2022 v1

%{
fnOpts = {'UniformOutput', false};
% Mean pixel position of the headplate and the nose to draw the middle
% reference line.
hnCoords = reshape( mean( dlcTable{:,{'headplate', 'nose'}}(:,[1,2,4,5]) ),...
    2, [] );
% Choosing the point with furthest distance from the origin. Should be the
% nose.
[~, noseSel] = max(vecnorm(hnCoords, 2, 2));
% Taking 1/5 from the nose or 4/5 from the headplate as a reference middle
% point.
midlPt = hnCoords(:, noseSel) - diff(hnCoords, 1, 2)/5;
% Getting the line that divides the mouse in half sagittally
mdl = fit_poly(hnCoords(1,:), hnCoords(2,:), 1);
refStruct = struct('MiddleLine', mdl, 'MiddlePoint', midlPt);
% [n, d] = getHesseLineForm(mdl);
% Getting the name of the variables to search for 'w' - whisker names, and
% nose.
avFlags = contains(string(dlcTable.Properties.VariableNames), ["w";"nose"]);
avNames = dlcTable.Properties.VariableNames(avFlags);
% Computing the slope for all whisker body parts and nose with respect to
% the middle point and then the angle m = (y_2 - y_1) / (x_2 - x_1)
m_bodyParts = (midlPt(2) - dlcTable{:, avNames}(:,2:3:end))./...
    (midlPt(1) - dlcTable{:, avNames}(:,1:3:end));
% Computing the angle between the bodypart and the reference line.
a_bodyParts = angleBetweenLines(mdl(1), m_bodyParts, 'deg');
% Unwrapping jumps from ±90 degrees using a variation from MATLAB unwrap
% function.
a_bodyParts = arrayfun(@(x) unwrapDLC(a_bodyParts(:,x), 90), 1:sum(avFlags),...
    fnOpts{:} );
% Wrapping up the results in a table.
a_bodyParts = table( a_bodyParts{:}, 'VariableNames', avNames );
%}

%% New analysis prototype
%Emilio Isaias-Camacho @GrohLab 2024 v2
% Number of 
Nframes = uint32( size( dlcTable, 1 ) );
rotMat = @(theta) [cos(theta), -sin(theta); ...
    sin(theta), cos(theta)];
rotateBy = @(A, theta) rotMat(theta) * A;

whisk_cols = cellfun(@(c) ~isempty(c), regexp( ...
    dlcTable.Properties.VariableNames, '[lr]w\d' ) );
circle_bodyparts = cellfun(@(c) ~isempty(c), ...
    regexp( dlcTable.Properties.VariableNames, '([lr]w\d|^[n])' ) );
proj_bodyparts = contains( dlcTable.Properties.VariableNames, ...
    {'nose', 'ueye'} );

eye2nose = zeros( Nframes, 1, "single" );
middle_snout = zeros( Nframes, 2, "single" );
mdl_yx = zeros( Nframes, 2, "single" );
nangle = zeros( Nframes, 1, "single" );
wangles = zeros( Nframes, 8, "single" );

circ_tbl = dlcTable{:, circle_bodyparts}(:, setdiff( 1:end, 3:3:end ) );
x_circ_coord = circ_tbl(:,1:2:end);
y_circ_coord = circ_tbl(:,2:2:end);

hp_tbl = dlcTable{:, 'headplate'}(:, setdiff( 1:end, 3:3:end ) );
x_hp_coord = hp_tbl(:,1:2:end);
y_hp_coord = hp_tbl(:,2:2:end);

proj_tbl = dlcTable{:, proj_bodyparts}(:, setdiff( 1:end, 3:3:end ) );
x_proj_coord = proj_tbl(:,1:2:end);
y_proj_coord = proj_tbl(:,2:2:end);

wx = dlcTable{:,whisk_cols}(:, 1:3:end);
wy = dlcTable{:,whisk_cols}(:, 2:3:end);
nx = dlcTable{:,"nose"}(:, 1:3:end);
ny = dlcTable{:,"nose"}(:, 2:3:end);

% Not general implementation! Only with the yx coordinate system!
angleWRTn = @(x,y,n) acosd( ([y(:), x(:)] * n(:)) ./ ...
    vecnorm( [x(:), y(:)], 2, 2 ) );

% Golden ratio
gr = ( ( 1 + sqrt(5) )/2 );

% Objective function for circle fit
sseval = @(theta, xdata, ydata) sum( ( sqrt( (xdata - theta(1)).^2 + ...
    (ydata - theta(2)).^2) - theta(3) ).^2 );

parfor cf = 1:Nframes
    
    % Fitting a circle to the whiskers and nose
    circTheta = fminsearch( @(x) sseval( x, x_circ_coord(cf,:)', ...
        y_circ_coord(cf,:)' ), [x_hp_coord(cf), y_hp_coord(cf), 40] );
    
    % Centre coordinates
    c_coords = circTheta(1:2);

    % Fitting a more stable line with a 90° rotation.
    mdl_yx(cf,:) = fit_poly( ... 
        [circTheta(2), y_hp_coord(cf)], ... Y coordinate
        [circTheta(1), x_hp_coord(cf)], 1)'; % X coordinate

    p_i = [y_proj_coord(cf,:)', x_proj_coord(cf,:)'];

    [n, d] = getHesseLineForm( mdl_yx(cf,:)' );
    p_p = p_i - ( n * (p_i * n - d)' )';

    % Golden ration from nose to the cicle centre
    wpivot_nose_d = pdist( [p_p(1,:); c_coords([2,1])] ) / gr;
    % Orthogonal vector to n
    n_orth = rotateBy( n, pi/2 );
    % Pivotal point for all whiskers
    w_pivot = p_p(1,:) + ( n_orth * wpivot_nose_d )';
    % Centering on the pivotal point
    wx_c = ( wx(cf,:) - w_pivot(2) ); wy_c = ( wy(cf,:) - w_pivot(1) );
    nx_c = ( nx(cf,:) - w_pivot(2) ); ny_c = ( ny(cf,:) - w_pivot(1) );

    % Getting angles of all whiskers w.r.t. the rotated n vector
    wangles(cf,:) = angleWRTn( wx_c, wy_c, n_orth )';
    % Angle of the nose w.r.t. the n vector
    nangle(cf) = angleWRTn( nx_c, ny_c, n );

    % Validation and verification variables
    eye2nose(cf) = pdist( p_p, "euclidean" );
    for ii = 1:2
        middle_snout(cf, ii) = circTheta(ii);
    end
end

avNames = { dlcTable.Properties.VariableNames{whisk_cols}, 'nose' };
a_bodyParts = table( 'Size', [Nframes, 9], ...
    'VariableTypes', repmat( "double", 1, 9 ) );
a_bodyParts{:,:} = [wangles, nangle];
a_bodyParts.Properties.VariableNames = avNames;

refStruct = struct( 'LinearEq', mdl_yx, 'Eye2NoseDist', eye2nose, ...
    'CircleCentre', middle_snout );

end

% Local function taken from the MATLAB implementation of the unwrap
% function LocalUnwrap.
function p = unwrapDLC(p, cutoff)
%LocalUnwrap   Unwraps column vector of phase values.
m = length(p);

% Unwrap phase angles.  Algorithm minimizes the incremental phase variation
% by constraining it to the range [-pi,pi]
dp = diff(p,1,1);                % Incremental phase variations

% Compute an integer describing how many times 2*pi we are off:
% dp in [-pi, pi]: dp_corr = 0,
% elseif dp in [-3*pi, 3*pi]: dp_corr = 1,
% else if dp in [-5*pi, 5*pi]: dp_corr = 2, ...
dp_corr = dp./(2*pi);

% We want to do round(dp_corr), except that we want the tie-break at n+0.5
% to round towards zero instead of away from zero (that is, (2n+1)*pi will
% be shifted by 2n*pi, not by (2n+2)*pi):
roundDown = abs(rem(dp_corr, 1)) <= 0.5;
dp_corr(roundDown) = fix(dp_corr(roundDown));

dp_corr = round(dp_corr);

% Stop the jump from happening if dp < cutoff (no effect if cutoff <= pi)
dp_corr(abs(dp) < cutoff) = 0;

% Integrate corrections and add to P to produce smoothed phase values
% taking the full range into consideration
p(2:m,:) = p(2:m,:) - (2*cutoff)*cumsum(sign(dp_corr),1);
end
